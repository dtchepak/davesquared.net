---
layout: post
title: "YAMT (sorry)"
date: 2013-01-09 12:21
updated: 2013-02-10 10:10
comments: true
categories: ["functional programming"]
---

This post is written to try and solidify my own understanding of what monads are, how they work, and why they are useful. I'm very much still learning this stuff myself, so please comment if you have any corrections or if any part of this doesn't make sense.

My [previous attempt to describe monads](http://davesquared.net/2012/06/fp-newbie-learns-monads.html) used Haskell examples, so I thought I'd try a more language-agnostic explanation. In this case most of the code samples are written in the closest we have to a universal language: JavaScript.

<!-- more -->

## What is a monad?

A monad is a pair of functions, commonly called `bind` and `unit`^[`bind` is also known as `SelectMany` in C#, `flatMap` in Scala, and the incredibly descriptive `>>=` in Haskell. `unit` is also known as `return`, `point` or `pure`.], that work on a particular type and obey [three laws](http://www.haskell.org/haskellwiki/Monad_Laws). 

Say we have `SomeType<A>`, which represents a type that has or calculates a value or values of another type.^[This is known as a [parameterised or generic type](http://en.wikipedia.org/wiki/Parameterized_type).]
 An example is a generic list, `List<A>`; we can have a list of `int`, a list of `string`, a list of `Foo`, etc.

The `bind` function takes two arguments: a `SomeType<A>`, and a function that converts an `A` to a `SomeType<B>`, and it returns a `SomeType<B>`.

The `unit` function returns values of `SomeType<A>` from a value of type `A`. This can be a constructor call in languages that use classes (`new SomeType<A>(A value)`).

A type has a monad instance if a pair of functions with these signatures exist for it (that satisfy the [three laws](http://www.haskell.org/haskellwiki/Monad_Laws) to make sure they work together sensibly^[The monad laws specify three properties that need to hold when combining these functions: that `bind(f, unit(a)) == f(a)`, that `bind(unit, m) == m`, and that `bind` is [associative](http://davesquared.net/2012/04/associativity.html).]). A useful approximation is an interface with two methods on it. A type can implement this interface by providing implementations for these two methods. As far as I can tell, the term "monad" refers to the general interface, while a "monad instance" is a specific implementation of this interface for a type.

<div class="note">**Example:** `IEnumerable<T>` in C# has a monad instance; it has a `SelectMany` function for `IEnumerable<T>` which matches the `bind` signature^[We looked at [how `SelectMany` matches the bind signature](/2012/06/fp-newbie-learns-monads.html#seriously-thats-it) in a previous post], and we can use the array, `List<T>` or other constructors as `unit`.</div>

This tells us what monads are, not what they do, but at least we've answered the first  question. What is a monad? A monad is a pair of functions with certain signatures.

## What does `bind` do?

The `bind` function looks quite similar to `map`, or `Select()` in C#. The `map` function transforms a `SomeType<A>` to a `SomeType<B>`, by applying a function that converts an `A` to a `B`, which we'll write `A → B`, to the value or values in `SomeType<A>`. 

`bind` also transforms a `SomeType<A>` to a `SomeType<B>`, but by applying a function that converts an `A → SomeType<B>`. If we tried to use `map` with a function `A → SomeType<B>` we'd get a `SomeType<SomeType<B>>` back.

```javascript
> productsInCategory(42);
[ 'earl grey', 'english breakfast' ]
> [42,101,418].map(productsInCategory);
[ [ 'earl grey', 'english breakfast' ],
  [ 'country', 'western' ],
  [ 'teapot' ] ]
```

<div class="note">**Note:** For this post whenever we use a `bind` function we are referring to one provided by a monad instance, not [JavaScript's built-in `bind` function](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/bind). Thanks to [José for pointing this out](https://twitter.com/jfroma/status/288858160712802304).</div>

Using `bind` still applies the conversion function, but flattens the result back to a `SomeType<B>`:

```javascript
> [42,101,418].bind(productsInCategory);
[ 'earl grey',
  'english breakfast',
  'country',
  'western',
  'teapot' ]
```

This difference lets `bind` do something `map` can't -- we can chain together multiple functions that return `SomeType` types, letting each function in the chain access the results of previous calls, and return a `SomeType` that represents the composition of all those computations.

```javascript
sample = function() {
    return bestSellingCategories().bind(function(category) {
    return productsInCategory(category.id).bind(function (product) {
    return [product + onSpecial(product, category)];
}); }); };
[ 'earl grey [ON SALE!]',
  'english breakfast [ON SALE!]',
  'country',
  'western [ON SALE!]',
  'teapot' ]
```

We could do the same nesting with `map` rather than `bind`, but then we'd end up with a `List<List<string>>` again.

This `bind` pattern is useful for more than just lists. For example, say we have a monad instance for `Async<A>`, a type which represents an async operation that, when told to run, will return an `A`. We have a `getOrder(int orderId)` function that returns an `Async<Order>`, and a `getShippingInfo(ShippingReference ref)` function that returns an `Async<ShippingInfo>`. We want to create a new function that returns an `Async<Bool>` that indicates whether a particular order can be modified.

```javascript
function canModifyOrder(int orderId) {
    return getOrder(orderId).bind(function (order) {
    return getShippingInfo(order.ShippingRef).bind(function (info) {
    return unit(!order.IsPaid && !info.HasShipped);
}); }); }
```

We could use the same code if, rather than dealing with `Async<A>`, we were dealing with an `Option<A>` type, which [represents a value that could be empty](http://davesquared.net/2012/12/optional-fp-in-csharp.html). If either `getOrder()` or `getShippingInfo()` returned empty, then the result of the computation would be empty.

This pattern crops up a lot -- for [functions that take the same argument type](http://davesquared.net/2012/08/reader-monad.html), for [maintaining state between function calls](http://davesquared.net/2012/10/state-monad.html) while keeping immutability, to [representing nullable or values that can be empty](http://davesquared.net/2012/12/optional-fp-in-csharp.html), for collections, and [lots more](http://en.wikipedia.org/wiki/Monad_(functional_programming)#Examples). It is common enough that some languages have built-in syntax to support it[^monadSyntax].

[^monadSyntax]: Some examples of monad-comprehension syntax:

    ```haskell
    --Haskell
    canModifyOrder orderId = do
        order <- getOrder orderId
        info <- getShippingInfo (shippingRef order)
        return not (isPaid order) && not (hasShipped order)
    ```

    ```csharp
    //C#
    var canModifyOrder =
        from order in GetOrder(orderId)
        from info in GetShippingInfo(order.ShippingRef)
        select !order.IsPaid && !info.HasShipped
    ```

    ```scala
    //Scala (approximate, I don't speak Scala)
    var canModifyOrder = for {
        order <- getOrder(orderId)
        info <- getShippingInfo(order.shippingRef())
    } yield (!order.IsPaid && !info.HasShipped)
    ```

So `bind` and `unit` (i.e. monads) give us a common pattern for chaining together types that have or compute values, where each step in the chain can access the results of previous step. 

## Composing computations

Different types vary in how they hold or compute their values. `List<A>` holds zero or more values (e.g. a list with 0, 1, or multiple values), `Option<A>` holds zero or one value, `Async<A>` will compute a single value asynchronously at some point in the future. Each monad instance for a type encapsulates what it means to compose computations of that type, so by calling `bind` and `unit` we know the resulting computation will do the correct thing.

From what I can tell, this is referred to as maintaining a *computation context*, or *monadic effect*. Once we start binding together lists, we are ultimately going to produce a new list as the result. If we are binding together async calls, our final result will be a computation that gets its result from async calls.

This helps us to keep some separation between the logic used for the monadic effect (encapsulated in `bind`, `unit` and the type), and how we want to use and combine those values (which we state in our calls to `bind` and `unit`). Monads keep those aspects decoupled for us.

<div class="note">**Aside:** Maintaining a computation context is also a downside to monads. If we want to combine different types of computations into a new context, say, an `Option<A>` and an `Async<A>` into an `Async<Option<A>>`, then we need a specific [monad transformer](http://en.wikibooks.org/wiki/Haskell/Monad_transformers) to define how this should work. This isn't a huge deal, but it is more complex than combining `map` calls that we can compose using standard [function composition](http://davesquared.net/2012/07/left-to-right-composition.html), which is why you'll sometimes hear that "monads don't compose".</div>

## Over 30 functions for the price of 2

There are benefits to the monad "interface" beyond just what specific implementations of `bind` and `unit` provide for a type. There are [surprisingly many functions](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#g:2) that can be implemented using only these two functions.

For example, `map` itself can be implemented using only `bind` and `unit`, and therefore for any monad^[So all monads are [functors](http://davesquared.net/2012/05/fp-newbie-learns-functors.html).]:

```javascript
function map(f, monad) {
    return monad.bind(function(x) {
        return monad.unit(f(x));
    }
}

> map(function(x) { return x+1; }, [1,2,3]);
[ 2, 3, 4 ]
```

We can also take any two argument function that works on standard `A` and `B` types, and turn that into a function that works with `SomeType<A>` and `SomeType<B>`.^[All monads are [applicative functors](http://davesquared.net/2012/05/fp-newbie-learns-applicatives.html).]

```javascript
lift2 = function(m, f, ma, mb) {
    return m.bind(function(a) {
        return m.bind(function(b) { return m.unit(f(a,b)); }, mb);
    }, ma);
}

> function add(x,y) { return x+y; }
> lift2(OptionMonad, add, new Option(2), new Option(3));
'{Just 5}'
> lift2(OptionMonad, add, new Option(2), Option.Empty());
'{Empty}'
```

This is written using only `bind` and `unit`, and so lets us reuse any existing function with any monad instance we have. We can write similar `lift` functions to support functions with any number of arguments.

Another we can write using only those functions is `sequence`, which will transform `List<SomeType<A>>` into `SomeType<List<A>>`[^sequenceEg]. This lets us do things like take an array of asynchronous operations, and transform them into an async operation that will produce an array of results.

[^sequenceEg]: An implementation of `sequence`:

    ```javascript
    sequence = function(m, list) {
        return list.reduce(function(acc, monad) {
            return m.bind(function(x) { 
                return m.map(function (ms) { return ms.concat(x); }, acc);
            }, monad);
        }, m.unit([]));
    };

    > sequence(OptionMonad, [new Option(1), new Option(3), new Option(5)]);
    '{Just [1,3,5]}'
    > sequence(OptionMonad, [new Option(1), Option.Empty, new Option(5)]);
    '{Empty}'
    ```

So the monad abstraction gives us a number of functions for combining types for free, all thanks to `bind` and `unit`.

## Conclusion

A monad is a pair of functions, `bind` and `unit`, that give us useful ways of combining types that hold or produce values (which we broadly label "computations"). 

    //C#-style:
    SomeType<B> bind(Func<A,SomeType<B>> f, SomeType<A> a);
    SomeType<A> unit(A value);

    -- Haskell-style:
    bind :: (a -> m b) -> m a -> m b
    unit :: a -> m a

A monad instance for a type that computes values lets us chain together those types to produce an aggregated computation, where each computation can access previous results. It also decouples the logic of how we want to put together multiple computations, from the implementation details of how "put together" works. 

The combination of `bind` and `unit` also give us many functions we can use with our type for free, like `map`, `lift` and `sequence`.

So where to from here? It's probably worth looking at specific monad instances like the [Option / Maybe monad](http://davesquared.net/2012/12/optional-fp-in-csharp.html) that can start giving immediate benefits with no risk. I've found starting there has made it easier for me to start thinking in terms of binding and mapping into types, which in turn makes it easier to see where [other monads](http://en.wikipedia.org/wiki/Monad_(functional_programming)#Other_examples) can be useful.

Hope this has helped!
