---
layout: post
title: "FP newbie learns a little about monads"
date: 2012-05-29 21:55
comments: true
published: false
categories: ["functional programming", "haskell"]
---

So after learning a little bit about [functors](/2012/05/fp-newbie-learns-functors.html) and [applicative functors](/2012/05/fp-newbie-learns-applicatives.html), finally I arrive at the notorious [monad](http://en.wikipedia.org/wiki/Monad_(functional_programming)).

<!-- more -->

It seems to me all these concepts actually have quite a bit in common; they are all about function application. Say we have a "normal" function `f :: a -> b`, we can apply it to an argument of type `a` and get back something of type `b`.

Sometimes we don't have a plain `a`, instead we have an `a` with some additional context or information around it. Say a list `[a]`, or `Maybe a` (which can hold a single `a` or nothing). We've got all these functions that already work on `a -> b`, so it would be nice to apply them to `a`'s in other contexts.

## Functors

One way to do this is with [functors](/2012/05/fp-newbie-learns-functors.html). Types that are instances of `Functor` all implement `fmap`:

    fmap :: Functor f => (a -> b) -> f a -> f b

This lets us map the function inside our context, and returns a result inside the same context.

    ghci> fmap (+1) [1..5]
    [2,3,4,5,6]
    ghci> fmap (+1) (Just 2)
    Just 3

In these examples we're applying the function `(+1)` over each element in a list, and inside the context of a `Maybe` value.

> Functors let us apply functions inside a context.

## Applicatives

What if our function `a -> b` is in a particular context as well, like a list of functions? We can apply these using [applicative functors](/2012/05/fp-newbie-learns-applicatives.html), which define an *apply* function denoted as `<*>`.

    (<*>) :: Applicative f => f (a -> b) -> f a -> f b

    ghci> [(+1), (+2), (*10)] <*> [1,2,3]
    [2,3,4,3,4,5,10,20,30]
    ghci> Just (+1) <*> (Just 4)
    Just 5

This turns out to be very useful, as it lets us apply functions with more than one argument inside a context, where standard functors only really helped with single argument functions.

    ghci> pure (+) <*> Just 10 <*> Just 20
    Just 30
    ghci> pure (+) <*> [1,2] <*> [3,4]
    [4,5,5,6]

For the first example, `pure` (also defined on `Applicative`) puts the `(+)` function into a `Maybe` context, `Just (+)`. We apply the first argument `Just 10` using `<*>` to give us `Just (10+)`, then applies the second argument to get our answer of `Just 30`.

> Applicative functors let us apply functions with multiple arguments to
> arguments inside a context.

## Monads

And so we come to monads. Monads define a few functions, the main ones being *bind*, denoted as `>>=`, and `return` (which works just like `pure` for applicatives):

    (>>=) :: Monad m => m a -> (a -> m b) -> m b
    return :: Monad m => a -> m a

This allows us to apply a function to an `m a` (an `a` in some context) that uses that `a` value to produce an `m b`; a new `b` in the same context. Any type that work with functions with these signatures (and [obey a couple of rules](http://www.haskell.org/haskellwiki/Monad_laws)) are monads.

    ghci> Just 42 >>= (\x -> return (x+2))
    Just 44

Here we've bound `Just 42` to a function. The bind operation with take the `42` out of the `Maybe` context and passes it into the bound function as `x`. This function uses `return (x+2)` to add 2 and put the result back into the `Maybe` context, which gives us `Just 44`.

What does this give us which `fmap (+2) (Just 42)` won't? The ability to chain, or *compose*, several of these bindings, and potentially handle failures along the way:


```haskell
ghci> Just 42 >>= (\x -> Just 28 >>= (\y -> return (x+y, x-y)))
Just (70,14)
ghci> Just 42 >>= (\x -> Nothing >>= (\y -> return (x+y, x-y)))
Nothing
```

Here we've composed several functions together that work in the `Maybe` context, producing a tuple that depends on the previous `x` and `y` values, all within the `Maybe` context. If one of the bindings produces `Nothing`, the whole expression reduces to `Nothing`.

In other words:

> Monads let us apply functions inside a context which depend on previous results

## Seriously? Is that it?

Yep, a monad is just another abstraction, like functors and applicative functors, to let us apply functions to values in various contexts. If you type works with a function with a bind-like signature, `m a -> (a -> m b) -> m b`, then there's a good chance you've got a monad. 

## No way can that be it!

Sure it can. If you've used LINQ in .NET, you may be familiar with this method:

```csharp
public static IEnumerable<TResult> SelectMany<TSource, TResult>(
	this IEnumerable<TSource> source,
	Func<TSource, IEnumerable<TResult>> selector
)
```

In other words, this method takes an `IEnumerable<A>` and a function which takes an `A` and returns an `IEnumerable<B>`, and then returns an `IEnumerable<B>`.

    -- Pseudo-code ahead!
    SelectMany :: IEnumerable<A> -> (A -> IEnumerable<B>) -> IEnumerable<B>
    (>>=)      ::     m a        ->     (a -> m b)        ->     m b

That's right, `SelectMany` is the bind operation for the `IEnumerable`, or collection, monad. While we're at it, the more common `Select` method corresponds to `fmap` (all monads happen to be functors as well).

## Why the fuss?

So answering the question "what is a monad?" is not too difficult; it's a type which has an appropriate bind function. Understanding the implications of this abstraction however, is a more involved task (and one I'm definitely not up to yet :)). This is probably why it is hard to get a straight answer from people when them what a monad is. "Anything that supports bind" is not a particularly useful answer, but explaining the myriad ways this abstraction is useful becomes quite involved.

<!--
implications:
seen applying functions insides a context, where final value depends on previous values
state, writer, reader monads (and lots more!)
IO monad for encapsulating side-effects
sequencing functions in languages like Haskell where evaluation order is not normally guaranteed
-->

