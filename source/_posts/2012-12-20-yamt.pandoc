---
layout: post
title: "YAMT (sorry)"
date: 2013-01-02 14:55
comments: true
categories: ["functional programming"]
---

I keep seeing material stating how terribly difficult monads are to understand. This perturbs me. Monads are not hard. They are not trivial either -- few things are if you look deep enough -- but they are definitely no more difficult than any other concepts in programming.

<!-- more -->

## What is a monad?

A monad is a pair of functions, `bind` and `return`, that work on a particular type and obey [three laws](http://www.haskell.org/haskellwiki/Monad_Laws). 

We'll go into the signatures of these functions in a moment, but for now we'll just say that a type has a monad instance if a pair of functions with these signatures exists for it. 

A useful approximation is an interface with two methods on it. A type can implement this "monad interface" by providing implementations for those two methods. The term "monad" refers to the general interface, while a "monad instance" is a specific implementation of this interface for a type.

## Prelude to a bind

I find the `bind` function easiest to understand when compared to `map` (also `fmap` in Haskell, or `Select` in C#).

`map` let's us take a function that converts a value of type `A` to a value of type `B`, and use it to convert a `SomeType<A>` to a `SomeType<B>`, by applying the `A -> B` conversion function to the value or values inside the `SomeType<A>`.

For example, we can map a function `intToWord` over `[1,2,3]` and get `["one", "two", "three"]`. The `intToWord` function got applied to every element in the list of integers, and we ended up with a list of words.

## Mapping and flattening, or `bind`

Now say we have a function that takes an `A` and returns a `SomeType<B>`. Again we'd like to map this function over `SomeType<A>` and get a `SomeType<B>`.

Our previous `map` function doesn't quite work, because if we convert each `A` into a `SomeType<B>`, we'll get a `SomeType<SomeType<B>>`. We want to flatten out this structure to get a `SomeType<B>`. 

An example is a function which takes an integer that represents a product category, and returns the names of all the products in that category. In other words, given an integer, it returns a list of strings (`Int -> [String]`). If we map this function across a list of integers, we'll get a list of lists. What we'd like to do is flatten this into a list of strings representing all the products in those categories (which we do with `concat` in Haskell).

```haskell
ghci> findProductsIn 42
["earl grey", "english breakfast"]
ghci> map findProductsIn [42,101,418]
[["earl grey","english breakfast"],["country","western"],["teapot"]]
ghci> concat (map findProductsIn [42,101,418])
["earl grey","english breakfast","country","western","teapot"]
```

This combination of map and flatten can be quite useful, and is often packaged into one function called "bind" in most literature, `SelectMany` in C#, `flatMap` in Scala, and the incredibly descriptive `>>=` in Haskell.

```haskell
ghci> [42,101,418] >>= findProductsIn
["earl grey","english breakfast","country","western","teapot"]
```

```csharp
csharp> new [] {42,101,418}.SelectMany(x => FindProductsIn(x));
{"earl grey","english breakfast","country","western","teapot"}
```

Notice the similarities between the signature of `map` and `bind`:

```haskell
map  :: (A -> B)           -> SomeType<A> -> SomeType<B>
bind :: (A -> SomeType<B>) -> SomeType<A> -> SomeType<B>
```

Bind works very similarly to `map`, only with an additional "flattening" step.

## `return`

The `return` function creates instances of our type from a value of type `A`. This can be a constructor call in languages that use classes (`new SomeType<A>(A value)`), or is a separate function called `unit`, `return`, `point` or `pure` in other languages (Haskell uses `return`).

For lists, `return 2` will produce `[2]`, a list containing `2` as an element. In C#, this is like `new List<int> { 2 }`.

## Why bother?

Types that have monad instances are useful because of the functionality they offer. The fact they are monads gives us helpful ways to compose them (using `map` and `bind`), and there are lots of functions we get for free when a type implements the monad interface, but this is not the key benefit.

Lists support map and bind (or `Select` and `SelectMany` in C# terms). But the useful thing about them is the can store zero or more values. The `Option<A>` or `Maybe<A>` types have monad instances, but their benefit is they represent zero or one value. An async call that will eventually return a value of type `A` has a monad instance, but it's benefit is it lets us represent and compose asynchronous computations, before we actually go off an execute it.

In other words, it is not the monad bit of types that is generally the most interesting, it is the types themselves. Supporting the monad interface just gives us some useful ways of using them.


