---
layout: post
title: "YAMT (sorry)"
date: 2013-01-02 14:55
comments: true
categories: ["functional programming"]
---

Monads are not trivial to understand -- few things are if you look deep enough -- but I don't think they are anywhere near as difficult as they are made out to be. In this post we'll look at what monads are, how they work, and why they are useful (which I think is in increasing order of difficulty). I'm very much still learning this stuff myself, so please post any corrections in the comments.

I've [previously attempted to describe monads](http://davesquared.net/2012/06/fp-newbie-learns-monads.html), but it was fairly Haskell-specific, and I wanted to try a more language-agnostic explanation.

<!-- more -->

## What is a monad?

A monad is a pair of functions, commonly called `bind` and `unit`^[`bind` is also known as `SelectMany` in C#, `flatMap` in Scala, and the incredibly descriptive `>>=` in Haskell. `unit` is also known as `return`, `point` or `pure`.], that work on a particular type and obey [three laws](http://www.haskell.org/haskellwiki/Monad_Laws). 

Say we have `SomeType<A>`, which represents a type that has or calculates a value or values of another type.^[This is known as a [parameterised or generic type](http://en.wikipedia.org/wiki/Parameterized_type).]
 An example is a generic list, `List<A>`; we can have a list of `int`, a list of `string`, a list of `Foo`, etc.

The `bind` function takes two arguments: a `SomeType<A>`, and a function that converts an `A` to a `SomeType<B>`, and it returns a `SomeType<B>`.

The `unit` function returns values of `SomeType<A>` from a value of type `A`. This can be a constructor call in languages that use classes (`new SomeType<A>(A value)`).

A type has a monad instance if a pair of functions with these signatures exist for it (that satisfy the 3 laws). A useful approximation is an interface with two methods on it. A type can implement this interface by providing implementations for these two methods. As far as I can tell, the term "monad" refers to the general interface, while a "monad instance" is a specific implementation of this interface for a type.

<div class="note">**Example:** `IEnumerable<T>` in C# has a monad instance; it has a `SelectMany` function for `IEnumerable<T>` which matches the `bind` signature^[We looked at [how `SelectMany` matches the bind signature](/2012/06/fp-newbie-learns-monads.html#seriously-thats-it) in a previous post], and we can use the array, `List<T>` or other constructors as `unit`.</div>

This tells us what monads are, not what they do, but at least we've answered the first  question. What is a monad? A monad is a pair of functions with certain signatures.

## What does `bind` do?

The first thing we need to work out is what `bind` does.

The `bind` function looks quite similar to `map`, or `Select` in C#. The `map` function transforms a `SomeType<A>` to a `SomeType<B>`, by applying a function that converts an `A` to a `B`, which we'll write `A → B`, to the value or values in `SomeType<A>`. 

`bind` also transforms a `SomeType<A>` to a `SomeType<B>`, but by applying a function that converts an `A → SomeType<B>`. If we tried to use `map` with a function `A → SomeType<B>` we'd get a `SomeType<SomeType<B>>` back.

```javascript
> productsInCategory(42);
[ 'earl grey', 'english breakfast' ]
> [42,101,418].map(productsInCategory);
[ [ 'earl grey', 'english breakfast' ],
  [ 'country', 'western' ],
  [ 'teapot' ] ]
```

Using `bind` still applies the conversion function, but flattens the result back to a `SomeType<B>`:

```javascript
> [42,101,418].bind(m.productsInCategory);
[ 'earl grey',
  'english breakfast',
  'country',
  'western',
  'teapot' ]
```

This difference lets `bind` do something `map` can't -- we can chain together multiple computations that return `SomeType` types, letting each function in the chain access the results of previous calls, and return a `SomeType` that represents the composition of all those computations.

```javascript
sample = function() {
    return bestSellingCategories().bind(function(category) {
    return productsInCategory(category.id).bind(function (product) {
    return [product + onSpecial(product, category)];
}); }); };
[ 'earl grey [ON SALE!]',
  'english breakfast [ON SALE!]',
  'country',
  'western [ON SALE!]',
  'teapot' ]
```

We could do the same nesting with `map` rather than `bind`, but then we'd end up with a `List<List<string>>` again.

This `bind` pattern is useful for more than just lists. For example, say we have a monad instance for `Async<A>`, a type which represents an async operation that, when told to run, will return an `A`. We have a `getOrder(int orderId)` function that returns an `Async<Order>`, and a `getShippingInfo(ShippingReference ref)` function that returns an `Async<ShippingInfo>`. We want to create a new function that returns an `Async<Bool>` that indicates whether a particular order can be modified.

```javascript
function canModifyOrder(int orderId) {
    return getOrder(orderId).bind(function (order) {
    return getShippingInfo(order.ShippingRef).bind(function (info) {
    return unit(!order.IsPaid && !info.HasShipped);
}); }); }
```

We could use the same code if, rather than dealing with `Async<A>`, we were dealing with an `Option<A>` type, which [represents a value that could be empty](http://davesquared.net/2012/12/optional-fp-in-csharp.html). If either `getOrder()` or `getShippingInfo()` returned empty, then the result of the computation would be empty.

This pattern crops up a lot -- for [functions that take the same argument type](http://davesquared.net/2012/08/reader-monad.html), for [maintaining state between function calls](http://davesquared.net/2012/10/state-monad.html) while keeping immutability, to [representing nullable or values that can be empty](http://davesquared.net/2012/12/optional-fp-in-csharp.html), for collections, and [lots more](http://en.wikipedia.org/wiki/Monad_(functional_programming)#Examples). It is common enough that some languages have built-in syntax to support it[^monadSyntax].

[^monadSyntax]: Some examples of monad-comprehension syntax:

    ```haskell
    --Haskell
    canModifyOrder orderId = do
        order <- getOrder orderId
        info <- getShippingInfo (shippingRef order)
        return not (isPaid order) && not (hasShipped order)
    ```

    ```csharp
    //C#
    var canModifyOrder =
        from order in GetOrder(orderId)
        from info in GetShippingInfo(order.ShippingRef)
        select !order.IsPaid && !info.HasShipped
    ```

    ```scala
    //Scala (approximate, I don't speak Scala)
    var canModifyOrder = for {
        order <- getOrder(orderId)
        info <- getShippingInfo(order.shippingRef())
    } yield (!order.IsPaid && !info.HasShipped)
    ```

So `bind` and `unit` (i.e. monads) give us a common pattern for chaining together types that have or compute values, where each step in the chain can access the results of previous step. 

## Composing computations

Different types will vary in how they hold or compute their values. `List<A>` holds zero or more values (e.g. a list with 0, 1, or multiple values), `Option<A>` holds zero or one value, `Async<A>` will compute a single value asynchronously at some point in the future. Each monad instance for a type encapsulates what it means to compose computations of that type, so by calling `bind` and `unit` we know the resulting type will do the correct thing.

From what I can tell, this is referred to as maintaining a *computation context*, or *monadic effect*. Once we start binding together lists, we are ultimately going to produce a new list as the result. If we are binding together async calls, our final result will be a computation that gets its result from async calls.

This helps us to keep some separation between the logic used for the monadic effect (kept in `bind`, `unit` and the type), and how we want to use and combine those values (which we state in our calls to `bind` and `unit`). Monads keep those aspects decoupled for us.

## Over 30 functions for the price of 2

There are benefits to the monad "interface" beyond just what specific implementations of `bind` and `unit` provide for a type. There are [surprisingly many functions](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#g:2) that can be implemented using only these two functions.

For example, `map` itself can be implemented for any monad^[So all monads are [functors](http://davesquared.net/2012/05/fp-newbie-learns-functors.html)]:

```javascript
function map(f, monad) {
    return monad.bind(function(x) {
        return monad.unit(f(x));
    }
}

> map(function(x) { return x+1; }, [1,2,3]);
[ 2, 3, 4 ]
```

We can also take any two argument function that works on standard `A` and `B` types, and turn that into a function that works with `SomeType<A>` and `SomeType<B>`.^[All monads are [applicative functors](http://davesquared.net/2012/05/fp-newbie-learns-applicatives.html)]

```javascript
lift2 = function(m, f, ma, mb) {
    return m.bind(function(a) {
        return m.bind(function(b) { return m.unit(f(a,b)); }, mb);
    }, ma);
}

> function add(x,y) { return x+y; }
> lift2(OptionMonad, add, new Option(2), new Option(3));
'{Just 5}'
> lift2(OptionMonad, add, new Option(2), Option.Empty());
'{Empty}'
```

This is written using only `bind` and `return`, and so lets us reuse any existing function with any monad we have. We can right similar `lift` functions to support functions with any number of arguments.

Another useful one is `sequence`, which will transform `List<SomeType<A>>` into `SomeType<List<A>>`.

```javascript
sequence = function(m, list) {
    return list.reduce(function(acc, monad) {
        return m.bind(function(x) { 
            return m.map(function (ms) { return ms.concat(x); }, acc);
        }, monad);
    }, m.unit([]));
};

> sequence(OptionMonad, [new Option(1), new Option(3), new Option(5)]);
'{Just [1,3,5]}'
> sequence(OptionMonad, [new Option(1), Option.Empty, new Option(5)]);
'{Empty}'
```

So the monad abstraction gives us a number of functions for combining types for free, all thanks to `bind` and `unit`.

## Conclusion


==============

Types that have monad instances are useful because of the functionality they offer. The fact they are monads gives us helpful ways to compose them (using `map` and `bind`), and there are lots of functions we get for free when a type implements the monad interface, but this is not the key benefit.

Lists support map and bind (or `Select` and `SelectMany` in C# terms). But the useful thing about them is the can store zero or more values. The `Option<A>` or `Maybe<A>` types have monad instances, but their benefit is they represent zero or one value. An async call that will eventually return a value of type `A` has a monad instance, but it's benefit is it lets us represent and compose asynchronous computations, before we actually go off an execute it.

In other words, it is not the monad bit of types that is generally the most interesting, it is the types themselves. Supporting the monad interface just gives us some useful ways of using them.


