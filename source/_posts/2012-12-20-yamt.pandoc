---
layout: post
title: "YAMT (sorry)"
date: 2013-01-02 14:55
comments: true
categories: ["functional programming"]
---

I keep seeing material stating how terribly difficult monads are to understand. This perturbs me. Monads are not hard. They are not trivial either -- few things are if you look deep enough -- but they are definitely no more difficult than any other concepts in programming.

<!-- more -->

## What is a monad?

A monad is a pair of functions, `bind` and `return`, that work on a particular type and obey [three laws](http://www.haskell.org/haskellwiki/Monad_Laws). 

We'll go into the signatures of these functions in a moment, but for now we'll just say that a type has a monad instance if a pair of functions with these signatures exists for it. 

A useful approximation is an interface with two methods on it. A type can implement this "monad interface" by providing implementations for those two methods. The term "monad" refers to the general interface, while a "monad instance" is a specific implementation of this interface for a type.

## Prelude to a bind

I find the `bind` function easiest to understand when compared to `map` (or `Select` in C#).

Say we have a [generic/parameterised type](http://en.wikipedia.org/wiki/Parameterized_type) that we'll call `SomeType<A>`. This represents a type that has, or calculates, values of some arbitrary type `A`.^[A good example is an array or list; it can be list of `int`, or of `string`, or of `Foo`. In other words, it is a `List<A>`, where `A` is some specific type.]

Say we have a function that takes an argument of type `A` and returns a result of type `B`. If we can apply the function to the value or values inside our `SomeType<A>`, we can convert it to a `SomeType<B>`.

A type that supports mapping a function like this is called a *[functor](/2012/05/fp-newbie-learns-functors.html)*. Just like a monad instance has a `bind` and `return` function, a functor instance has a `map` function:

    -- Haskell:
    map :: (a -> b) -> f a -> f b

    -- C#:
    public static SomeType<B> Select(this SomeType<A> a, Func<A,B> f);

    -- Pseudo-English:
    Given a function that takes an A and returns a B
    And a SomeType<A>
    Then return SomeType<B>

    -- Pseudo-code example:
    map(add1ThenConvertToString, [1,2,3]) = ["2","3","4"]

## Mapping and flattening, or `bind`

Now say we have a function that takes an `A` and returns a `SomeType<B>`. Again we'd like to map this function over `SomeType<A>` and get a `SomeType<B>`.

Our previous `map` function doesn't quite work, because if we convert all our `A`s into `SomeType<B>`s, we'll get a `SomeType<SomeType<B>>`. We want to flatten out this structure to get a `SomeType<B>`. Taking lists as an example:

    -- Pseudo-code example:
    map(intToArray, [1,2,3]) = [[1], [2,2], [3,3,3]]
    flatten(map(intToArray, [1,2,3])) = [1,2,2,3,3,3]

This combination of map and flatten can be quite useful, and is often packaged into one function called "bind" in most literature, `SelectMany` in C#, `flatMap` in Scala, and the incredibly descriptive `>>=` in Haskell.

    -- Haskell:
    (>>=) :: m a -> (a -> m b) -> f b
    -- With arguments flipped it looks just like map:
    (=<<) :: (a -> m b) -> m a -> m b
    fmap :: (a -> b) -> f a -> f b

    -- C#:
    public static SomeType<B> SelectMany(this SomeType<A> a, Func<A,SomeType<B>> f);

    -- Pseudo-English:
    Given a function that takes an A and returns a SomeThing<B>
    And a SomeType<A>
    Then return SomeType<B>

    -- Pseudo-code example:
    bind(findProducts, ["tea", "coffee"]) 
        = ["earl grey", "english breakfast", "herbal tea", "short black"]

## `return`

The `return` function creates instances of our type from a value of type `A`. This can be a constructor call in languages that use classes (`new SomeType<A>(A value)`), or is a separate function called `unit`, `return`, `point` or `pure` in other languages (Haskell uses `return`).

    -- Haskell:
    return :: a -> m a

    -- C#:
    public static SomeType<A> Return(A a);
    // or:
    class SomeType<A> { public SomeType<A>(A value) { ... } }

    --Pseudo-English:
    Given an A
    Then return a SomeType<A>

    --Example: Array
    return(2) = [2]

## Why bother?

Types that have monad instances are useful because of the functionality they offer. The fact they are monads gives us helpful ways to compose them (using `map` and `bind`), and there are lots of functions we get for free when a type implements the monad interface, but this is not the key benefit.

Lists support map and bind (or `Select` and `SelectMany` in C# terms). But the useful thing about them is the can store zero or more values. The `Option<A>` or `Maybe<A>` types have monad instances, but their benefit is they represent zero or one value. An async call that will eventually return a value of type `A` has a monad instance, but it's benefit is it lets us represent and compose asynchronous computations, before we actually go off an execute it.

In other words, it is not the monad bit of types that is generally the most interesting, it is the types themselves. Supporting the monad interface just gives us some useful ways of using them.


