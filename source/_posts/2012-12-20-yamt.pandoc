---
layout: post
title: "YAMT (sorry)"
date: 2013-01-02 14:55
comments: true
categories: ["functional programming"]
---

Monads are not trivial to understand -- few things are if you look deep enough -- but I don't think they are anywhere near as difficult as they are made out to be. 

I've [previously attempted to describe monads](http://davesquared.net/2012/06/fp-newbie-learns-monads.html), but it was fairly Haskell-specific, and I wanted to try a more language-agnostic explanation.

<!-- more -->

## What is a monad?

A monad is a pair of functions, commonly called `bind` and `unit`^[`bind` is also known as `SelectMany` in C#, `flatMap` in Scala, and the incredibly descriptive `>>=` in Haskell. `unit` is also known as `return`, `point` or `pure`.], that work on a particular type and obey [three laws](http://www.haskell.org/haskellwiki/Monad_Laws). 

Say we have a type `SomeType<A>`, which is a type that has or calculates a value or values of another type.^[This is known as a [parameterised or generic type](http://en.wikipedia.org/wiki/Parameterized_type). An example is lists; we can have a list of `int`, or a list of `string`. Another example is asynchronous calls; one could calculate a result that is a `Foo`, while another calculates a `Bar`.]

The `bind` function takes two arguments: a `SomeType<A>`, and a function that converts an `A` to a `SomeType<B>`, and it returns a `SomeType<B>`.

The `unit` function returns values of `SomeType<A>` from a value of type `A`. This can be a constructor call in languages that use classes (`new SomeType<A>(A value)`).

A type has a monad instance if a pair of functions with these signatures exist for it (that satisfy the 3 laws). A useful approximation is an interface with two methods on it. A type can implement this interface by providing implementations for these two methods. As far as I can tell, the term "monad" refers to the general interface, while a "monad instance" a specific implementation of this interface for a type.

<div class="note">**Example:** `IEnumerable<T>` in C# has a monad instance; it has a `SelectMany` function for `IEnumerable<T>` with the required `bind` signature^[We looked at [how `SelectMany` matches the bind signature](/2012/06/fp-newbie-learns-monads.html#seriously-thats-it) in a previous post], and we can use the array, `List<T>` or other constructors as `unit`.</div>

This tells us what monads are, not what they do, but it is important we don't confuse the two questions. What is a monad? A monad is a pair of functions with certain signatures.

## What does a monad do?

There are two parts to what monads do for us. One is related to the particular monad instance we are talking about; what does the specific implementation of the `bind` method for a type do? The other is what the general monad "interface" lets us do.

## What does `bind` do?

The first step to understanding what monads give us is the `bind` function.

The `bind` function looks quite similar to `map`, or `Select` in C#. The `map` function transforms a `SomeType<A>` to a `SomeType<B>`, by applying a function that converts an `A` to a `B`, which we'll write `A -> B`. 

`bind` also transforms a `SomeType<A>` to a `SomeType<B>`, but by applying a function that converts an `A -> SomeType<B>`. If we tried to use `map` with a function `A -> SomeType<B>` we'd get a `SomeType<SomeType<B>>` back.

```javascript
> productsInCategory(42);
[ 'earl grey', 'english breakfast' ]
> [42,101,418].map(productsInCategory);
[ [ 'earl grey', 'english breakfast' ],
  [ 'country', 'western' ],
  [ 'teapot' ] ]
```

Using `bind` still applies the conversion function, but flattens the result back to a `SomeType<B>`:

```javascript
> [42,101,418].bind(m.productsInCategory);
[ 'earl grey',
  'english breakfast',
  'country',
  'western',
  'teapot' ]
```

This difference lets `bind` do something `map` can't -- we can chain together multiple computations that return `SomeType` types, letting each function in the chain access the results of previous calls, and return a `SomeType` that represents the composition of all those computations.

```javascript
sample = function() {
    return bestSellingCategories().bind(function(category) {
    return productsInCategory(category.id).bind(function (product) {
    return [product + onSpecial(product, category)];
}); }); };
[ 'earl grey [ON SALE!]',
  'english breakfast [ON SALE!]',
  'country',
  'western [ON SALE!]',
  'teapot' ]
```

We could do the same nesting with `map` rather than `bind`, but then we'd end up with a `List<List<string>>` again.

This `bind` pattern is useful for more than just lists. For example, say we have a monad instance for `Async<A>`, a type which represents an async operation that, when told to run, will return an `A`. We have a `getOrder(int orderId)` function that returns an `Async<Order>`, and a `getShippingInfo(ShippingReference ref)` function that returns an `Async<ShippingInfo>`. We want to create a new function that returns an `Async<Bool>` that indicates whether a particular order can be modified.

```javascript
function canModifyOrder(int orderId) {
    return getOrder(orderId).bind(function (order) {
    return getShippingInfo(order.ShippingRef).bind(function (info) {
    return unit(!order.IsPaid && !info.HasShipped);
}); }); }
```

We could use the same code if, rather than dealing with `Async<A>`, we were dealing with an `Option<A>` or `Maybe<A>` type, which [represents a value that could be empty](http://davesquared.net/2012/12/optional-fp-in-csharp.html). If either `getOrder()` or `getShippingInfo()` returned empty, then the result of the computation would be empty.

## Composing computations

This pattern crops up [lots](http://davesquared.net/2012/08/reader-monad.html) and [lots](http://davesquared.net/2012/10/state-monad.html) and [lots](http://davesquared.net/2012/12/optional-fp-in-csharp.html) and  [lots](http://en.wikipedia.org/wiki/Monad_(functional_programming)#Examples) of times, so much so that some languages have built-in syntax to support it[^monadSyntax].

[^monadSyntax]: Some examples of monad-comprehension syntax:

        --Haskell
        canModifyOrder orderId = do
            order <- getOrder orderId
            info <- getShippingInfo (shippingRef order)
            return not (isPaid order) && not (hasShipped order)
        //C#
        var canModifyOrder =
            from order in GetOrder(orderId)
            from info in GetShippingInfo(order.ShippingRef)
            select !order.IsPaid && !info.HasShipped
        //Scala (approximate, I don't speak Scala)
        var canModifyOrder = for {
            order <- getOrder(orderId)
            info <- getShippingInfo(order.shippingRef())
        } yield (!order.IsPaid && !info.HasShipped)

This brings us to our first, major benefit of monads -- they provide a common pattern for types to chain together calls that use the values computed by the type, by providing an implementation of `bind` and `unit`. 

The process of computation for these types is sometimes called a *computation context*, or a *monadic effect*, which is carried through each step in the chain of calls. For `List<A>`, the context is a collection of values, for `Option<A>` it is zero or one values, for `Asyc<A>`, it is a value that will be calculated asynchronously later on. The monad instance encapsulates this, so all we need to do is call `bind` and we know the type's implementation will do the correct thing.

## Why monads matter

There are benefits to the monad "interface" beyond just want specific implementations of `bind` and `unit` provide for a type. There are [surprisingly many functions](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#g:2) that can be implemented using only these two functions.

For example, `map` itself can be implemented for any monad:

```javascript
function map(f, monad) {
    return monad.bind(function(x) {
        return monad.unit(f(x));
    }
}

> map(function(x) { return x+1; }, [1,2,3]);
[ 2, 3, 4 ]
```

Another useful one is `sequence`, which will transform `[SomeType<A>]` into `SomeType<[A]>`.


## Conclusion


==============

## What does this give us?

So a monad consists of a `bind` and `return` function. That's it. How can this be useful?

First, it gives us ways of combining


//e.g. map, sequence


## It the type that makes the monad

Types that have monad instances are useful because of the functionality they offer. The fact they are monads gives us helpful ways to compose them (using `map` and `bind`), and there are lots of functions we get for free when a type implements the monad interface, but this is not the key benefit.

Lists support map and bind (or `Select` and `SelectMany` in C# terms). But the useful thing about them is the can store zero or more values. The `Option<A>` or `Maybe<A>` types have monad instances, but their benefit is they represent zero or one value. An async call that will eventually return a value of type `A` has a monad instance, but it's benefit is it lets us represent and compose asynchronous computations, before we actually go off an execute it.

In other words, it is not the monad bit of types that is generally the most interesting, it is the types themselves. Supporting the monad interface just gives us some useful ways of using them.


