---
layout: post
title: "YAMT (sorry)"
date: 2013-01-02 14:55
comments: true
categories: ["functional programming"]
---

I keep seeing material stating how terribly difficult monads are to understand. This perturbs me. Monads are not hard. They are not trivial either -- few things are if you look deep enough -- but they are definitely no more difficult than any other concepts in programming.

<!-- more -->

## What is a monad?

A monad is a pair of functions, `bind` and `return`, that work on a particular type and obey [three laws](http://www.haskell.org/haskellwiki/Monad_Laws). 

We'll go into the signatures of these functions in a moment, but for now we'll just say that a type has a monad instance if a pair of functions with these signatures exists for it. 

A useful approximation is an interface with two methods on it. A type can implement this "monad interface" by providing implementations for those two methods. As far as I can tell, the term "monad" refers to the general interface, while a "monad instance" is a specific implementation of this interface for a type.

## Prelude to a bind

I find the `bind` function easiest to understand when compared to `map` (also `fmap` in Haskell, or `Select` in C#).

`map` let's us take a function that converts a value of type `A` to a value of type `B`, and use it to convert a `SomeType<A>` to a `SomeType<B>`, by applying the `A -> B` conversion function to the value or values inside the `SomeType<A>`.

For example, we can map a function `intToWord` over `[1,2,3]` and get `["one", "two", "three"]`. The `intToWord` function got applied to every element in the list of integers, and we ended up with a list of words.

## Mapping and flattening, or `bind`

Now say we have a function that takes an `A` and returns a `SomeType<B>`. Again we'd like to map this function over `SomeType<A>` and get a `SomeType<B>`. Our previous `map` function doesn't quite work, because if we convert each `A` into a `SomeType<B>`, we'll get a `SomeType<SomeType<B>>`. We want to flatten out this structure to get a `SomeType<B>`. 

For example, let's take a function that returns a list of product names for a particular product category. In other words, it takes an integer and returns a list of strings. Given a list of categories, we'd like to get a list of products in those categories. 

```javascript
> findProductsIn(42)
["earl grey", "english breakfast"]

// map gives us a list of lists
> map(findProductsIn, [42,106,418])
[["earl grey","english breakfast"],["country","western"],["teapot"]]

> flatten(map(findProductsIn, [42,106,418]))
["earl grey","english breakfast","country","western","teapot"]

> bind(findProductsIn, [42,106,418]))
["earl grey","english breakfast","country","western","teapot"]
```

This combination of mapping and flattening can be quite useful, and is often packaged into one function called "bind" in most places, `SelectMany` in C#, `flatMap` in Scala, and the incredibly descriptive `>>=` in Haskell.

<div class="note">
**Aside:** Notice the similarities between `map` and `bind`:

    map  :: (A -> B)           -> SomeType<A> -> SomeType<B>
    bind :: (A -> SomeType<B>) -> SomeType<A> -> SomeType<B>

They both apply functions to the value or values in `SomeType<A>`, but `map` works works with functions `A -> B` while `bind` works with functions `A -> SomeType<B>`.
</div>

## `return`

The `return` function creates instances of our type from a value of type `A`. This can be a constructor call in languages that use classes (`new SomeType<A>(A value)`), or is a separate function called `unit`, `return`, `point` or `pure` in other languages (Haskell uses `return`).

For lists, `return 2` will produce `[2]`, a list containing `2` as an element. In C#, this is like `new List<int> { 2 }`.

## It's the type that makes the monad

So far we've been looking at examples of `bind` and `return` for list types. That is just one particular implementation of the monad "interface".

## What does this give us?

So a monad consists of a `bind` and `return` function. That's it. How can this be useful?

First, it gives us ways of combining

There are [surprisingly many functions](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#g:2) that can be implemented using only these two functions.

//e.g. map, sequence




## Why bother?

Types that have monad instances are useful because of the functionality they offer. The fact they are monads gives us helpful ways to compose them (using `map` and `bind`), and there are lots of functions we get for free when a type implements the monad interface, but this is not the key benefit.

Lists support map and bind (or `Select` and `SelectMany` in C# terms). But the useful thing about them is the can store zero or more values. The `Option<A>` or `Maybe<A>` types have monad instances, but their benefit is they represent zero or one value. An async call that will eventually return a value of type `A` has a monad instance, but it's benefit is it lets us represent and compose asynchronous computations, before we actually go off an execute it.

In other words, it is not the monad bit of types that is generally the most interesting, it is the types themselves. Supporting the monad interface just gives us some useful ways of using them.


