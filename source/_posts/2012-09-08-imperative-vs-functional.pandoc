---
layout: post
title: "It's a mutable, imperative world out there"
date: 2012-09-02 12:49
comments: true
published: false
categories: ["functional programming", "imho"]
---

I've heard Erik Meijer quoted as saying the world is imperative and mutable, and so we should embrace side-effects^[Erik Meijer from GOTO Night August 23, 2012 in Chicago: [one](https://twitter.com/codemiller/status/238780672439885824), [two](https://twitter.com/codemiller/status/238783944043151360), [three](https://twitter.com/puffnfresh/status/238779939053252608)]. I've also heard what I interpret as [pretty much the opposite from Rich Hickey](http://www.infoq.com/presentations/Value-Values). So, which is it? 

I have no idea, so instead I thought I'd write a story.

## Luckily no one was killed

It was a brisk winter's night. I had just parked my car down at The Rocks, a beautiful part of Sydney right on the Harbour, and had started hurrying down George Street to attend the monthly Drop Bear Awareness Society meetup. I had only gone a couple of hundred metres when hordes of people started flooding out of Circular Quay, accompanied by yells, screams and sirens. I was swept along with the crowd, herded by police and emergency services into Town Hall station and onto waiting trains. As my train pulled away from the platform I only knew one thing for certain; people were talking about a "monster" with a disturbing amount of credulity.

Turns out that a 50 metre high dinosaur-like monster had chosen that day to emerge from the depths of Sydney Harbour and take a brief stroll through the CBD. It was apparently on land for about 10 minutes, after which time it had grown bored and decided go back out to sea and head to Melbourne where it could destroy something more tasteful. 

I returned to my car the next day. It was flattened; the imprint of a giant footprint clearly visible in the twisted wreckage. But I wasn't going to give up on my beloved car. It took weeks of extensive work at the smash repairer, but I finally got my car back, pretty much as good as new.

## State, mutations and time

There are two ways of looking at this story (three if you count "as an unimaginative, poorly-told piece of tripe"). One is from the perspective of mutable state, as commonly associated with imperative programming^[Imperative programming can also be done without mutable state, although [some definitions](http://en.wikipedia.org/wiki/Imperative_programming) include mutability as an essential feature.]. I had a working car, then the car's state changed to "smashed by monstrous dinosaur", the it changed back to working. It was the same car, its state was just changed, and rather forcibly at that. We can even write a program to express what happened:

    var car = new Car("British Leyland Mini 1000");
    Console.WriteLine(car.State); // prints "Working"
    car.SmashWith(new DinosaurThing()); 
    Console.WriteLine(car.State); // prints "Smashed"
    car.Repair();
    Console.WriteLine(car.State); // prints "Working"

There is an implied part of this representation of the story: time. Any state change requires a change in time, although this representation does not mention it explicitly. We have several states in this program, but the one state property is over-written at various times so when we talk about state, we are only referring to the latest, current state. We don't have any access to the times these occur, nor to previous states; we only use the latest. Because time is implicit, it is possible for operations to interfere. Two operations executing at the same time or out-of-order can result in an inconsistent state or erase a state before it had a chance to be observed.

There is another, equally valid way of thinking about this story. In this telling we make the time variable explicit. The state of my car is a function of time:

    public static CarState GetCarState(Time t) {
        if (t < 0) 
            return CarState.Working;
        else if (t >= 0 && t < 10) 
            return CarState.Smashed;
        else 
            return CarState.Working;
    }

Here we still have state changes, but they aren't destructive. Just because my car is now fixed does not mean that is was never smashed by a giant, 50 metre high mostrosaur. That state was still perfectly valid, it was just at a different time. Because time is an explicit input it is not possible to get interfering states. The output depends purely on the input, is defined for all values of `t`.

## Immutability

One implication of treating state as a function of time is that data becomes immutable. Once we have data for some time `t`, that data is never going to change; we can't change the past. A change in data will require a change in time.

We don't have to lose the imperative story by explicitly handling time. We can just make the data immutable:

    var car = new Car("British Leyland Mini 1000");
    var smashedCar = car.SmashWith(new DinosaurThing());
    var repairedCar = smashedCar.Repair();

Here we don't interfere with previous states; they are still perfectly valid for the time they occurred. After all, we can't change the past. And we can still return the state of our car as a function of time. 

We have different instances of data representing the one car, but we can associate these using identity (the car's VIN, make, model, etc.). The state of a car with a specific identity can be considered a function of time and identity with an immutable data representation as the output. Again, all these states are valid, they actually occurred in the story, and we just need to be explicit on which moment of reality we need to work with.

## Imperative world?

So the world is imperative, full of mutations and side-effects. Well, is it really? It seems equally valid to say that the world is a function of time (and other variables) that outputs immutable states. Are both perspectives two sides of the same coin?

To me the equivalence of these perspectives matches my admittedly-basic-and-quite-probably-wrong interpretation of the [Church-Turing thesis](http://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis): all computable programs are computable by both a Turing machine and using the λ-calculus. A Turing machine relies on mutable state, λ-calculus on pure functions. They're all able to express the same set of programs, and they can all represent "real world" information and calculations. 

<!-- FINAL EDITS
I find this realisation quite interesting, as it leads me to the conclusion I can make much greater use of immutable data in my programs and keep the same level

A potentially more valuable question for software developers is which perspective makes programs easier to reason about. If the answer to this varies, what is it about a particular problem that makes one perspective a better match than the other? What to we gain and lose by using each perspective? How much is our opinion swayed by the "primacy of the machine"?
-->

## Conclusion

In summary, don't park right next to a large, city-side harbour unless you have comprehensive car insurance.

