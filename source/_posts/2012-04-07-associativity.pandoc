---
layout: post
title: "Associativity"
date: 2012-04-07 09:15
comments: true
categories: ["functional programming"]
---

One of the nice things about pure functional programming is that we can use mathematical properties and axioms to reason about, simplify and derive functions. A property that I've seen crop up a few times while reading is [associativity](http://en.wikipedia.org/wiki/Associativity).

<!-- more -->

## Associativity property

Associativity is a property of some binary operators that means the order operators are evaluated does not matter. An operator $\oplus$ is associative if:

$$(x \oplus y) \oplus z = x \oplus (y \oplus z)$$

A familiar example is $+$. We can safely write $1 + 2 + 3$ and know we'll get the correct answer irrespective of the order in which it is evaluated, as $(1 + 2) + 3 = 1 + (2 + 3)$. An example of a non-associative operator is $-$, as $(1-2)-3 \neq 1-(2-3)$.

Two operators are said to associate if they can be evaluated in any order:

$$(x \oplus y) \otimes z = x \oplus (y \otimes z)$$

In terms of functional programming, a binary operator is a two argument function. We tend to refer to operators as functions used in [infix](http://en.wikipedia.org/wiki/Infix_notation) position, or between arguments like ``a `f` b``, as opposed to _function notation_, which is the more familiar `f a b` arrangement. A function can be associative regardless of the notation used. Our previous $+$ example could be rewritten in function notation as `(+) ((+) 1 2) 3 = (+) 1 ((+) 2 3)`.

Associativity seems particularly useful for reasoning about [folds](http://davesquared.net/2012/03/folds-pt3-left-fold-right.html). If we don't have to worry about the order of evaluation, this can simplify how we think about using the function. For example, if `f` is associative, then `foldr f a = foldl f a`. It is also part of the definition of a _monoid_ which ends up flowing through to concepts like _monads_. 

## Operator associativity

Related to this mathematical property is [operator associativity](http://en.wikipedia.org/wiki/Operator_associativity) or _fixity_, which is essentially an exercise in parenthesis-saving. For non-associative operations where order of evaluation matters, we can define the operator as _left-associative_ or _right-associative_ depending on how we want it to evaluate in the absence of parentheses.

$$\begin{align}
\text{For a left-associative operator: } \\
x \oplus y \oplus z &= (x \oplus y) \oplus z \\
\\
\text{For a right-associative operator: } \\
x \otimes y \otimes z &= x \otimes (y \otimes z)\\
\end{align}$$

For maths and programming I've always erred on the side of over-specifying parentheses, but as I get more into functional programming I've found learning operator associativity starts to really reduce the noise. One example is _function composition_ using the `(.)` operator. Because this is an associative operation, we can compose a string of functions without the noise of parentheses: `f . g . h`.

