---
layout: post
title: "Associativity"
date: 2012-04-04 22:22
comments: true
categories: ["functional programming"]
published: false
---


I've never paid much attention to the concept of [associativity](http://en.wikipedia.org/wiki/Associativity) before (I mean, it just relates to where you put parenthesis right?), but while reading [Introduction to Functional Programming](http://www.amazon.com/Introduction-Functional-Programming-International-Computing/dp/0134841972/) I've noticed that there are a few concepts (like _monoids_) which depend on the property. 

<!-- more -->

Associativity is a property of some binary operators that means the order the operators are evaluated does not matter. So for some associative operator $\oplus$:

$$(x \oplus y) \oplus z = x \oplus (y \oplus z)$$

A familiar example is $+$, where $(1 + 2) + 3 = 1 + (2 + 3)$. Because it is associative, we can safely write $1 + 2 + 3$ and know that we'll get the correct answer, irrespective of the order in which it is evaluated. An example of a non-associative operator is $-$, as $(1-2)-3 \neq 1-(2-3)$.

Two operators are said to associate if they can be evaluated in any order:

$$(x \oplus y) \otimes z = x \oplus (y \otimes z)$$

In terms of functional programming, a binary operator is a two argument function using in [infix](http://en.wikipedia.org/wiki/Infix_notation) position, or between the arguments like ``a `f` b``, as opposed to _function notation_, which is the more familiar `f a b` arrangement. 

## Operator associativity

Related to this mathematical property is [operator associativity](http://en.wikipedia.org/wiki/Operator_associativity) or _fixity_, which is essentially an exercise is parenthesis-saving. For non-associative operations where order of evaluation matters, we can define the operator as _left-associative_ or _right-associative_ depending on how we want it to evaluate in the absence of parentheses.

$$\begin{align}
\text{For a left-associative operator:} \\
x \oplus y \oplus z &= (x \oplus y) \oplus z\\
\\
\text{For a right-associative operator:} \\
x \otimes y \otimes z &= x \otimes (y \otimes z)\\
\end{align}$$

For maths and programming I've always erred on the side of over-specifying parentheses, but as I get more into functional programming I've found learning operator associativity does start to really reduce the noise. One example is _function composition_. Because this is an associative operation, it can save a lot of noise when composing functions together:

$$\begin{align}
(f \circ g) \circ h &= f \circ (g \circ h) \\
                    &= f \circ g \circ g
\end{align}$$

More importantly I've noticed associativity has some implications for reasoning about [folds](http://davesquared.net/2012/03/folds-pt3-left-fold-right.html), and is a part of the definition of a _monoid_. I'm sure I'll come across a number of other functional programming concepts that use this concept as I continue to read up on the subject.


