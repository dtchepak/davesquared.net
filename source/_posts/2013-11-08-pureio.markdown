---
layout: post
title: "Freely representing pure IO"
date: 2013-11-08 12:00
comments: true
categories: ["functional programming", "f#"]
---

Previously we looked at [using IO without side-effects](/2013/04/side-effect-free-csharp.html) in C# by deferring the execution of side-effects. Rather than performing IO, we wrapped up side-effecting operations in an `IO` type and used combinators like `Select`, `Then` and `SelectMany` to work within that type, all without actually having to execute the side-effect.

This is a useful technique, but it has the drawback that the `IO` instances assembled with these combinators are opaque -- there is no way for us to inspect them and work out what the represent. We know an `IO<String>` is some IO operation that will result in a string, but is it `readLine`, or `launchMissilesAndShowStatus`?

In this post we'll look at another way of representing side-effecting (and other) operations that addresses this drawback.

<!-- more -->

## Motivation

Let's use IO as an example again:

```fsharp
let helloWorld() =
    Console.WriteLine "Hi, what's your name?"
    let name = Console.ReadLine()
    Console.WriteLine ("Hello " + name)
```
This representation combines definition and execution. We can isolate the rest of our program from the effects of this execution by [wrapping it in an `IO` type](/2013/04/side-effect-free-csharp.html), but then we end up with an opaque box of `IO ()`. If a function returns an `IO ()`, there is no way we can inspect it to find out what it is doing. We can't distinguish `helloWorld()` from `launchMissiles`. 

What we'd like to do is separate the definition of this program from its execution. By representing programs that do terminal IO with a data type, we can use it in different ways; inspecting it to see what it does, running it with a pure interpreter, or executing it and performing the effect it defines.

This is all a bit hand-wavy at this point, so let's get to specifics.

## Representing operations with data

There are two main operations used by our `helloWorld()` program, `WriteLine` and `ReadLine`. These operations are chained together in a specific order -- we write a prompt, we read some input, we write a greeting based on that input, and then we end the program. Let's represent these operations, and the idea of chaining them together, with a `Terminal` data type:

```fsharp
type Terminal =
    | WriteLine of string * Terminal
    | ReadLine of (string -> Terminal)
    | EndProgram
```

* `WriteLine` -- takes a `string` to write, and the next `Terminal` to run.
* `ReadLine` -- takes a function which, given a `string` read in via IO, will return the next `Terminal` to run. This means the next operation to run after reading a line can depend on the value read.
* `EndProgram` -- takes no arguments, so does not specify a next `Terminal`. Once we get here our terminal program can have no more operations. It's done.

We know that any `Terminal` program can only do these operation. No confusing `helloWorld()` and `launchMissles()` anymore. As we'll see later, we can also differentiate two `Terminal` programs.

We can represent our original `helloWorld()` using the `Terminal` data structure:

```fsharp
let helloWorld2 : Terminal =
    WriteLine ("Hi, what's your name?", 
        ReadLine (fun name -> 
            WriteLine ("Hello " + name, EndProgram)))
```

This is clumsy, but we'll improve things as we go along. For now fill in the gap between this and the original `helloWorld()`: executing the program.

## Interpreting operations

We're now separated the definition of `helloWorld()` from it's execution. Now we can define an interpreter that will execute not just `helloWorld()`, but any `Terminal` program.

```fsharp
let rec interpretIO (term:Terminal) : Unit =
    match term with
        | WriteLine (s, next) -> Console.WriteLine s; interpretIO next
        | ReadLine f          ->
            let read = Console.ReadLine()
            interpretIO (f read)
        | EndProgram -> ()
```

This interpreter traverses the given `Terminal`, translating each operation to an effect (reading or writing lines), and then recursively calling itself to interpret the next operation in the chain. The recursion stops at `EndProgram`.

    > helloWorld();;
    Hi, what's your name?
    World
    Hello World
    val it : unit = ()
    > interpretIO helloWorld2;;
    Hi, what's your name?
    World
    Hello World
    val it : Unit = ()

We now have parity with our original program. We've split the program's definition from its execution, giving us pure, side-effect-free representation of a side-effecting program. But is it worth the increased complexity, the author asked rhetorically?

## Pure interpreters

This split of definition and execution opens up some interesting possibilities. For example, we can interpret this program using a purely functional interpreter which reads from a stack of inputs and produces a list of outputs. Very useful for testing!

```fsharp
let interpretPure (input:string Stack) (term:Terminal) : string list =
    let rec step i o t =
        match t with
            | WriteLine (s, next) -> step i (s :: o) next
            | ReadLine f          ->
                let (line, i') = pop i
                let next = f (line |?? "")
                step i' o next
            | EndProgram -> List.rev o
    step input [] term
(* fsi:
    > interpretPure (Stack ["World"]) helloWorld2;;
    val it : string list = ["Hi, what's your name?"; "Hello World"]
*)
```

We could also write other interpreters, say one that pretty prints a program so we can see exactly what an instance of `Terminal` is doing, or one that translates our `Terminal` program to another language like Javascript.

The benefits of this separation doesn't stop at IO, we could model database operations like this, and have different interpreters to perform those operations against SQL Server, RavenDB, an in-memory datastore and the filesystem.

## Composing `Terminal` programs

Our current implementation suffers from one big problem; we can't combine `Terminal` programs. We have to define a full `Terminal` program upfront, as each operation also defines what the next operation is going to be. Speaking of which, assembling programs that are more complex than `helloWorld2` is going to get very messy.

So let's add a new item to our list of aims: we'd like to be able to compose `Terminal` programs so it's easy to build them, while still keeping the benefits of separate definitions and execution.

## Separating primitive operations from recursion

There first steps towards composing these operations is removing the need for each operation to specify the next operation. We still need to be able to chain together operations, but we'll separate this job out into two data types, one for the primitive operations, and another to handle recursion part of the old `Terminal` data type:

```fsharp
type Terminal<'a> =
    | WriteLine of string  * 'a
    | ReadLine of (string -> 'a)
type FreeTerm<'a> =
    | Pure of 'a
    | FreeTerm of Terminal<FreeTerm<'a>>
```

We now have a funny looking `Terminal` definition. `WriteLine`, for example, takes the `string` to write, but also some value of some generic type `'a` instead of the next `Terminal` operation to execute. This generic parameter lets us define the `FreeTerm` type which we can use to chain `Terminal` operations together (using the `FreeTerm of Terminal<FreeTerm<'a>>` constructor, or end the recursive definition (using the `Pure of 'a` constructor). 

Using these two types, our program becomes:

```fsharp
let helloWorld3 =
    FreeTerm (WriteLine ("Hi, what's your name?", 
                FreeTerm (ReadLine (fun name -> 
                    FreeTerm (WriteLine (("Hello " + name), Pure ()))))))
```

We'll also need to update our interpreters to match `FreeTerm` instead of `Terminal`. For example:

```fsharp
let rec interpretIO (term:FreeTerm<'a>) : 'a =
    match term with
        | FreeTerm (WriteLine (s, next)) -> Console.WriteLine s; interpretIO next
        | FreeTerm (ReadLine f) ->
            let read = Console.ReadLine()
            interpretIO (f read)
        | Pure a -> a
```

## Combining primitives

We're not done yet. We can define some general functions to help us update and combine these types, and from there build some helper functions to give us a much nicer way of defining our `Terminal` IO progarms.

The first function we need is `mapTerm`, which will let us transform a `Terminal<'a>` into a `Terminal<'b>` if we can change `'a -> 'b`.

```fsharp
let mapTerm (f : 'a -> 'b) (term : Terminal<'a>) : Terminal<'b> =
    match term with
        | WriteLine (s, value) -> WriteLine (s, f value)
        | ReadLine fn          -> ReadLine (f << fn)
```

This `mapTerm` function lets us define `bind` to chain together `FreeTerm<>` values, and `liftF` to take a `Terminal<'a>` operation and wrap it in the `FreeTerm<'a>` type:

```fsharp
let rec bind (f : 'a -> FreeTerm<'b>) (term : FreeTerm<'a>) : FreeTerm<'b> =
    match term with
        | Pure value -> f value
        | FreeTerm t -> FreeTerm (mapTerm (bind f) t)

let liftF (term:Terminal<'a>) : FreeTerm<'a> = 
    FreeTerm (mapTerm Pure term)
```

We can use these as the basis for a nice way to expression our terminal IO programs.

```fsharp
let (>>=) = fun term f -> bind f term
let (>>) = fun t1 t2 -> t1 >>= fun _ -> t2
let writeLine s : FreeTerm<Unit> = liftF (WriteLine (s, ()))
let readLine : FreeTerm<string> = liftF (ReadLine id)

let helloWorld4 : FreeTerm<Unit> =
    writeLine "Hi, what's your name?" >> 
    readLine >>= fun name -> 
    writeLine ("Hello " + name)
```

## Computation expression syntax

I'm quite happy with `helloWorld4()`, but we can also use [computation expressions](http://fsharpforfunandprofit.com/series/computation-expressions.html) to get what is possibly a more familiar-looking syntax:

```fsharp
type TermBuilder() =
    member x.Bind(term, f) = bind f term
    member x.Return(value) = Pure value
    member x.Combine(term1, term2) = term1 >> term2
    member x.Zero() = Pure ()
    member x.Delay(f) = f()
let termIO = new TermBuilder()

let helloWorld5 = termIO {
    do! writeLine "Hi, what's your name?"
    let! name = readLine
    do! writeLine ("Hello " + name)
}
```

## More general solutions

Much of the work we did define `FreeTerm` and the relevant combinators can be eliminated by using a more generalised type called [`Free`](http://hackage.haskell.org/package/free-2.0.3/docs/Control-Monad-Free.html#t:Free). I'm not sure how to express the more general form in F#, but the fact it exists means defining a specific `FreeX` type for each `X` is quite fast and mechanical.

In a language with higher-order polymorphism like Haskell we can get `Free` for [all types we can map over](/2012/05/fp-newbie-learns-functors.html) for, well, free. Here is the entire example in Haskell:

```haskell
{-# LANGUAGE DeriveFunctor #-}
import Control.Monad.Free

data Terminal a =
    WriteLine String a
    | ReadLine (String -> a)
    deriving (Functor)

writeLine :: String -> Free Terminal ()
writeLine s = liftF $ WriteLine s ()
readLine :: Free Terminal String
readLine = liftF $ ReadLine id

helloWorld :: Free Terminal ()
helloWorld = do
    writeLine "Hi, what's your name?"
    name <- readLine
    writeLine $ "Hello " ++ name

interpretIO :: Free Terminal a -> IO a
interpretIO (Free (WriteLine s a)) = putStrLn s >> interpretIO a
interpretIO (Free (ReadLine f)) = getLine >>= interpretIO . f
interpretIO (Pure a) = return a
```

## Conclusion

We can get a pure representation of any side-effecty program by defining a type for the primitive operations required for the program and a corresponding `Free` type. This `Free` type and related combinators is quite general, and even in languages where we can't use a generalised version, it is a fast and mechanical process to write one.

In return, we are able to limit the expression of programs to a set of known operations so we can tell their potential and limitations just from the types, compared with general IO which could try and do anything. We also get the ability to define multiple interpreters for these programs for testing, optimisation, targeting multiple platforms, inspection, etc.

<!-- motivations:

What we'd like to achieve is:

* separate the definition of these programs from their execution
* be able to limit the operations of programs to a set of known operations (not all-bets-are-off-IO)
* be able to distinguish between two programs of the same type

* be able to run a single program in different ways, so we can run it with side-effects or in a pure way for testing, or to target different environments.

-- optimise programs, interpret to batch expensive ops, etc
-- possible in C#
-- much more general in Haskell (not sure how general it can be made in F#)

-- DSL
-->
