---
layout: post
title: "State monad and random strings"
date: 2012-09-02 12:49
comments: true
published: false
categories: ["functional programming", "haskell"]
---

During some recent work I found the need to use a State monad. Unfortunately I had no idea how to do this. In this post we'll retrace the steps I took while trying to generate random strings with Haskell. We'll start by coding specific, non-monadic pieces to solve the problem, then generalise this by implementing our own State monad, before finally switching over to use Haskell's State monad. By the end of it we'll hopefully all understand the State monad (which is more than I can say for when I first started tackling this problem :)).

If you've never encountered monads before then you may want to start with this [introduction to monads](http://davesquared.net/2012/06/fp-newbie-learns-monads.html) (yes, yes, Yet Another Monad tutorial. Feel free to [read a good one instead](http://www.haskell.org/haskellwiki/Monad_tutorials_timeline) if you don't like mine :)).

<!-- more -->

## A little context

So I found myself needing to generate random strings to anonymise the data in a bunch of fields. Using a `replaceField` function I was able to replace the field contents with a hard coded string, like this:

    ghci> input
    ["first: hello","second: world","third: !!!"]
    ghci> map (replaceField "abc") input
    ["first: abc","second: abc","third: abc"]

Now I just needed to replace the `"abc"` string with randomly generated strings. 

<div class="note">**Aside:** I think we can actually use [QuickCheck](http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck2) to generate arbitrary strings for us. But where's the fun in that?</div>

## Random characters

To get a (pseudo-)random value we can use Haskell's `System.Random` module:

    ghci> import System.Random
    ghci> :t randomR
    randomR :: (RandomGen g, Random a) => (a, a) -> g -> (a, g)

The `randomR` function takes as input a tuple with the lower and upper-bounds of the random value to generate, and a random number generator. It's output is a tuple consisting of a random value within those bounds, and a new generator which will generate the next random value in the sequence. (This will work for any type `a` that is an instance of the `Random` type class, and any generator `g` which is an instance of `RandomGen`.) We can use it like this:

    ghci> let g = mkStdGen 42
    ghci> randomR (1,10) g
    (2,1720602 40692)
    ghci> randomR ('a','z') g
    ('n',1720602 40692)

Here we've seeded a new generator with the number `42` and generated a number between `(1,10)` to get `2`, and a character between `('a','z')` to get `'n'`. So we've got random character generation under control.

## Multiple random characters

To get a new random value we're going to have to use `randomR` again, but this time with the new generator from the tuple outputted by our previous call. (Remember Haskell functions are pure; their output depends purely on their input. If we pass the same generator `mkStdGen 42` as input we'll get exactly the same "random" character as output.) We'll have to keep feeding each generator that comes out of one call as input to the next call:

    ghci> let (a', g') = randomR ('a','z') g
    ghci> let (a'',g'') = randomR ('a','z') g'
    ghci> let (a''',g''') = randomR ('a','z') g''
    ghci> let (a'''',g'''') = randomR ('a','z') g'''
    ghci> let (a''''',g''''') = randomR ('a','z') g''''
    ghci> [a', a'', a''', a'''', a''''']
    "ndfeo"

To generate a string of some length `i`, we'll need to call this `randomR ('a','z')` function `i` times, accumulating both the string value and the generator at each step. Let's hack this out:

```haskell
import System.Random

getRandomChar :: RandomGen g => g -> (Char, g)
getRandomChar = randomR ('a','z')

getRandomStringWithLength :: RandomGen g => Int -> g -> (String, g)
getRandomStringWithLength i g =
    let charGenerators = replicate i getRandomChar
    in  foldr apply ([], g) charGenerators

apply :: (a -> (b, a)) -> ([b], a) -> ([b], a)
apply f (xs, g) = let (x, g') = f g
                  in  (x:xs, g')
```

Here we've used the name `getRandomChar` to refer to the `randomR ('a','z')` function which will give us a single character plus a new generator. 

We've also got a `getRandomStringWithLength` function which takes an integer (how many characters long the string should be) and a generator, and outputs the resulting string and the last generator produced. It calls `replicate i getRandomChar`, which will output a list of `getRandomChar` functions. If we call `replicate 3 getRandomChar`, we'll get `[getRandomChar, getRandomChar, getRandomChar]`. We need to reduce this list, accumulating characters and the most recent generator as we go.

For that `getRandomStringWithLength` uses a [fold](http://davesquared.net/2012/02/folds-pt1-from-recursion-to-folds.html). The fold's initial value (seed) is an empty list and the first generator passed in (`([],g)`), and from there we `apply` each of the `charGenerators`.

The `apply` function is fairly hideous. It takes the current `getRandomChar` function and the `(string, generator)` value accumulated in the fold, applies the function to that generator, and outputs a tuple of `(newString, newGenerator)`. (To be honest I just wrote down the required type signature and that was really the only implementation I could think of that would satisfy it.) But, hideousness aside, we now have a function that will generate a random string of characters:

    ghci> getRandomStringWithLength 5 (mkStdGen 42)
    ("oefdn",1421974012 652912057)

## Encapsulating state

So let's tidy up this mess I've made. The `getRandomChar` function takes some initial generator, and outputs a tuple with a character and a new generator. A more general way to think of this is as a function `s -> (a,s)`, so that for some initial state `s`, we want to output a value `a` and a new state of `s`. We'll wrap this computation up in a new data type, representing a `Stateful` computation:

    newtype Stateful s a = Stateful { runState :: s -> (a,s) }

Now we can modify `getRandomChar` to output a `Stateful` computation, and we can run through that state using `runState`:

    randomChar :: (RandomGen g) => Stateful g Char
    randomChar = Stateful $ randomR ('a','z')

    ghci> runState randomChar (mkStdGen 42)
    ('n',1720602 40692)

## Combining stateful computations

Now what we want to do is to chain together functions which work on states, so that the state output from one function gets fed into the input of the next function (which we saw in [Multiple random characters](#multiple-random-characters)). In [my take on monads](http://davesquared.net/2012/06/fp-newbie-learns-monads.html#monads) I concluded "Monads let us apply functions inside a context which depend on previous results". In this case our next random number depends on the generator produced by the previous call. So let's wire up a monad instance based on our `Stateful` type, so that when we bind two stateful computations, the new state produced by one gets passed as the input to the next:

```haskell
instance Monad (Stateful s) where
    -- For a monad m:
    --   (>>=) :: m a -> (a -> m b) -> m b
    -- For (Stateful s), substitute for m:
    --   (>>=) :: Stateful s a -> (a -> Stateful s b) -> Stateful s b
    statefulA >>= f 
        = Stateful $ \s ->
                let (a, s')   = runState statefulA s
                    statefulB = f a
                in runState statefulB s'

    -- return :: a -> m a
    -- return :: a -> Stateful s a
    return a = Stateful $ \s -> (a, s)
```

The bind function `>>=` is where all the work gets done. By substituting `Stateful s` into the required type signature, we can see bind needs to take a stateful computation which produces an `a`, and a function which takes an `a` and outputs a new stateful computation `Stateful s b`. The entire bind function ultimately outputs a `Stateful s b`, a stateful computation that combines the result of the initial `Stateful s a` and the `Stateful s b` produced from the `a -> Stateful s b` function, feeding through the correct state at each step. Let's go through the steps required to satisfy this function signature.

### Stepping through the bind implementation

The first argument is a stateful computation that produces an `a`. Let's call this `statefulA`. The second argument is a function `f` that given an `a` will produce a stateful computation that will give us a `b`. The final output will need to be a new `Stateful s b`, which is a type that holds a function `s -> (b, s)`. So we'll start by creating this state, `State $ \s -> ...`.

The function in this new stateful computation, when given a state `s`, will run `statefulA` to produce a tuple containing an `a` and new state `s'`. If we feed this `a` into the function `f` we'll get a new stateful computation that produces a `b`, which we'll call `statefulB`. 

We can't just output `statefulB` though. Its type is `statefulB :: Stateful s b`, so the output from our `>>=` function would be `Stateful s (Stateful s b)` rather than `Stateful s b`. We need to get the `b` out of that inner expression; flatten the structure out. To do this we call `runState statefulB s'`, which gets the `b` out of `statefulB` by passing through the new state `s'` from the previous call. In this way we ensure that the state transformation from `s` to `s'` is passed through to the next bound function, which was our aim from the beginning.

For completeness, the `return` function takes some value `a` and returns a `Stateful` computation that, given a state `s`, will always produce that value `a` and the same state `s`. In other words, it takes an ordinary value and puts it into the context of a stateful computation that takes a state and returns `(value, state)`.

<div class="note">**Aside:** We should also make `Stateful` and instance of `Functor` and `Applicative` (all monads are also functors and applicative functors), but I'll omit that step as this post is long enough already. If you'd like me to go through it let me know. We should also make sure that our monad implementation satisfies the [Monad Laws](http://www.haskell.org/haskellwiki/Monad_Laws), but again, long post, so let's press on.</div>

## Using our shiny new monad instance to generate strings

So we have a `randomChar` function which produces a `Stateful g Char` computation, and we have a shiny new monad instance that lets us combine computations. We now have everything we need to run a stateful computation that will produce a random string, or a `Stateful g [Char]`. 

Let's take stock of what we have so far:

``` haskell
getRandomChar :: RandomGen g => g -> (Char, g)
getRandomChar = randomR ('a','z')

getRandomStringWithLength :: RandomGen g => Int -> g -> (String, g)
getRandomStringWithLength i g =
    let charGenerators = replicate i getRandomChar
    in  foldr apply ([], g) charGenerators

-- snip --
newtype Stateful s a = Stateful { runState :: s -> (a,s) }
instance Monad (Stateful s) where 
    statefulA >>= f = ...
    return a = ...
-- snip --

randomChar :: (RandomGen g) => Stateful g Char
randomChar = Stateful $ randomR ('a','z')

randomStringWithLength :: (RandomGen g) => Int -> Stateful g String
randomStringWithLength i = undefined -- ???
```

Our original `getRandomStringWithLength` function called `replicate i getRandomChar` to get a `[g -> (Char, g)]`. If we use our new function, `replicate i randomChar`, we get `[Stateful g Char]`. We'd like a way to convert a `[Stateful g Char]` to a `Stateful g [Char]`. 

Haskell has a built-in function called [`sequence`](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:sequence), which does just this. For some monad `m`, it has the signature `[m a] -> m [a]`. Substituting in for our `Stateful s` monad, this gives us `[Stateful s a] -> Stateful s [a]`. Which means we can generate a random string from `randomChar` like this:

``` haskell
randomStringWithLength :: (RandomGen g) => Int -> Stateful g String
randomStringWithLength i = sequence (replicate i randomChar)
                   -- or = (sequence . replicate i) randomChar
                   -- or = replicateM i randomChar
```

I assume this pattern of `replicate` and `sequence` is fairly common, has Haskell provides a [`replicateM`](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#v:replicateM) function that does just this.


<!-- ****** IN PROGRESS ****** -->


## References

* ["How to use random numbers?", Albert Y. C. Lai](http://www.vex.net/~trebla/haskell/random.xhtml)

