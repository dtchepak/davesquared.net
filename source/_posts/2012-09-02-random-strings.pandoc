---
layout: post
title: "State monad and random strings"
date: 2012-09-02 12:49
comments: true
published: false
categories: ["functional programming", "haskell"]
---

During some recent work I found the need to use a State monad. Unfortunately I had no idea how to do this. In this post we'll retrace the steps I took while trying to generate random strings with Haskell. We'll start by coding specific, non-monadic pieces to solve the problem, then generalise this by implementing our own State monad, before finally switching over to use Haskell's State monad. By the end of it we'll hopefully all understand the State monad (which is more than I can say for when I first started tackling this problem :)).

If you've never encountered monads before then you may want to start with this [introduction to monads](http://davesquared.net/2012/06/fp-newbie-learns-monads.html) (yes, yes, Yet Another Monad tutorial. Feel free to [read a good one instead](http://www.haskell.org/haskellwiki/Monad_tutorials_timeline) if you don't like mine :)).

<!-- more -->

## A little context

So I found myself needing to generate random strings to anonymise the data in a bunch of fields. Using a `replaceField` function I was able to replace the field contents with a hard coded string, like this:

    ghci> input
    ["first: hello","second: world","third: !!!"]
    ghci> map (replaceField "abc") input
    ["first: abc","second: abc","third: abc"]

Now I just needed to replace the `"abc"` string with randomly generated strings. 

<div class="note">**Aside:** I think we can actually use [QuickCheck](http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck2) to generate arbitrary strings for us. But where's the fun in that?</div>

## Random characters

To get a (pseudo-)random value we can use Haskell's `System.Random` module:

    ghci> import System.Random
    ghci> :t randomR
    randomR :: (RandomGen g, Random a) => (a, a) -> g -> (a, g)

The `randomR` function takes as input a tuple with the lower and upper-bounds of the random value to generate, and a random number generator. It's output is a tuple consisting of a random value within those bounds, and a new generator which will generate the next random value in the sequence. (This will work for any type `a` that is an instance of the `Random` type class, and any generator `g` which is an instance of `RandomGen`.) We can use it like this:

    ghci> let g = mkStdGen 42
    ghci> randomR (1,10) g
    (2,1720602 40692)
    ghci> randomR ('a','z') g
    ('n',1720602 40692)

Here we've seeded a new generator with the number `42` and generated a number between `(1,10)` to get `2`, and a character between `('a','z')` to get `'n'`. So we've got random character generation under control.

## Multiple random characters

To get a new random value we're going to have to use `randomR` again, but this time with the new generator from the tuple returned from our previous call. (Remember Haskell functions are pure; their output depends purely on their input. If we pass the same generator `mkStdGen 42` as input we'll get exactly the same "random" character as output.) We'll have to keep feeding each generator that comes out of one call as input to the next call:

    ghci> let (a', g') = randomR ('a','z') g
    ghci> let (a'',g'') = randomR ('a','z') g'
    ghci> let (a''',g''') = randomR ('a','z') g''
    ghci> let (a'''',g'''') = randomR ('a','z') g'''
    ghci> let (a''''',g''''') = randomR ('a','z') g''''
    ghci> [a', a'', a''', a'''', a''''']
    "ndfeo"

To generate a string of some length `i`, we'll need to call this `randomR ('a','z')` function `i` times, accumulating both the string value and the generator at each step. Let's hack this out:

```haskell
import System.Random

getRandomChar :: RandomGen g => g -> (Char, g)
getRandomChar = randomR ('a','z')

getRandomStringWithLength :: RandomGen g => Int -> g -> (String, g)
getRandomStringWithLength i g =
    let charGenerators = replicate i getRandomChar
    in  foldr apply ([], g) charGenerators

apply :: (a -> (b, a)) -> ([b], a) -> ([b], a)
apply f (xs, g) = let (x, g') = f g
                  in  (x:xs, g')
```

Here we've used the name `getRandomChar` to refer to the `randomR ('a','z')` function which will give us a single character plus a new generator. 

We've also got a `getRandomStringWithLength` function which takes an integer (how many characters long the string should be) and a generator, and outputs the resulting string and the last generator produced. It calls `replicate i getRandomChar`, which will return a list of `getRandomChar` functions. If we call `replicate 3 getRandomChar`, we'll get `[getRandomChar, getRandomChar, getRandomChar]`. We need to reduce this list, accumulating characters and the most recent generator as we go.

For that `getRandomStringWithLength` uses a [fold](http://davesquared.net/2012/02/folds-pt1-from-recursion-to-folds.html). The fold's initial value (seed) is an empty list and the first generator passed in (`([],g)`), and from there we `apply` each of the `charGenerators`.

The `apply` function is fairly hideous. It takes the current `getRandomChar` function and the `(string, generator)` value accumulated in the fold, applies the function to that generator, and returns a tuple of `(newString, newGenerator)`. (To be honest I just wrote down the required type signature and that was really the only implementation I could think of that would satisfy it.) But, hideousness aside, we now have a function that will generate a random string of characters:

    ghci> getRandomStringWithLength 5 (mkStdGen 42)
    ("oefdn",1421974012 652912057)

## Encapsulating state

So let's tidy up this mess I've made. The `getRandomChar` function takes some initial generator, and returns a tuple with a character and a new generator. A more general way to think of this is as a function `s -> (a,s)`, so that for some initial state `s`, we want to return a value `a` and a new state of `s`. We'll wrap this computation up in a new data type:

    newtype State s a = State { runState :: s -> (a,s) }

Now we can modify `getRandomChar` to return a `State`, and we can run through that state using `runState`:

    randomChar :: (RandomGen g) => State g Char
    randomChar = State $ randomR ('a','z')

    ghci> runState randomChar (mkStdGen 42)
    ('n',1720602 40692)

## Combining stateful computations

Now what we want to do is to chain together functions which work on states, so that the state output from one function gets fed into the input of the next function (which we saw in [Multiple random characters](#multiple-random-characters)). In [my take on monads](http://davesquared.net/2012/06/fp-newbie-learns-monads.html#monads) I concluded "Monads let us apply functions inside a context which depend on previous results". In this case our next random number depends on the generator produced by the previous call. So let's wire up a monad instance based on our state type, so that when we bind a state to a function, the new state gets passed as the input to that function:

```haskell
instance Monad (State s) where
    -- For a monad m:
    --   (>>=) :: m a -> (a -> m b) -> m b
    -- For (State s), substitute for m:
    --   (>>=) :: State s a -> (a -> State s b) -> State s b
    sa >>= f  = State $ \s ->
                let (a, s') = runState sa s
                    sb        = f a
                in runState sb s'

    -- return :: a -> m a
    -- return :: a -> State s a
    return a = State $ \s -> (a, s)
```

The bind function `>>=` is where all the work gets done. By substituting `State s` into the required type signatue, we can see bind needs to take a state which produces an `a`, and a function which takes an `a` from a state and returns a new state `State s b`, and outputs that `State s b`.

So the first argument is a state context that produces an `a`. Let's call this `sa`. The second argument is a function `f` that given an `a` will produce a state context that will give us a `b`. The output will need to be a new `State s b`, which is a type that holds a function `s -> (b, s)`. So we'll start by creating this state, `State $ \s -> ...`.

This function in this new state, when given a state `s`, will run `sa` to produce a tuple containing an `a` and new state `s'`. If we feed this `a` into the function `f` we'll get a state that produces a `b`, which we'll call `sb`. 

We can't just output `sb` though. Its type is `sb :: State s b`, so the output from out `>>=` function would be `State s (State s b)` rather than `State s b`. We need to get the `b` out of that inner expression; flatten the structure out. To do this we call `runState sb s'`, which gets the `b` out of `sb` by passing through the state `s'` from the previous call. In this way we ensure that the state transformation from `s` to `s'` get passed through to the next bound function.

For completeness, the `return` function takes some value `a` and returns a `State` that, given a state `s`, will always produce that value `a` and the same state `s`. In other words, it takes an ordinary value and puts it into the context of a calculation that takes a state and returns `(value, state)`.

## Using our shiny new monad instance

We can now use our state monad to produces strings of a certain length.

<!-- IN PROGRESS ->










Remember our `getRandomStringWithLength` function called `replicate i getRandomChar` to get a `[g -> (Char, g)]`? Well if we use our new function, `replicate i randomChar`, we get `[State g Char]`. So somewhere along the line we're going to want a function `State g Char -> (g -> [State g Char]) -> State g String`.

    instance Monad (State s) where
        return a = State $ \s -> (a, s)
        a >>= f  = State $ \s ->
                    let (a', s') = runState a s
                        b        = f a'
                    in runState b s'



<!-- ODDS and ENDS -->

Notice we have to take the generator produced by each call to `randomR`, and send that through to the next call? In [my take on monads](http://davesquared.net/2012/06/fp-newbie-learns-monads.html#monads) I concluded "Monads let us apply functions inside a context which depend on previous results". Each function here depends on the generator from the previous result, so it sounds like a good fit for a monad. I vaguely remember being able to map and fold monads, so we could apply one over a list of fields. I can even take a guess that we'll need the State monad, as we need to maintain the state of the generator between calls. Unfortunately I have absolutely no idea how to use the state monad. So it's time for plan B.

## Hacking together something that works

Let's start small; generating a single, random character, and returning a new generator along with it (so we can continue the sequence):

```haskell
getRandomChar :: RandomGen g => g -> (Char, g)
getRandomChar = randomR ('a','z')
```

/* MAYBE TACKLE THE FOLD FIRST? DO FIXED LENGTH RANDOM STRING? */
```haskell
getRandomString :: RandomGen g => g -> (String, g)
getRandomString g = 
    let (charsToGen, g') = randomR (1, 10) g
        chars            = replicate charsToGen getRandomChar
    in  foldr apply ([], g') chars

apply :: (a -> (b, a)) -> ([b], a) -> ([b], a)
apply f (xs, g) = let (x, g') = f g
                  in  (x:xs, g')
```



-- handles this by giving us generators we can pass around that will generate streams of pseudo-random numbers.

## References

* ["How to use random numbers?", Albert Y. C. Lai](http://www.vex.net/~trebla/haskell/random.xhtml)

