---
layout: post
title: "Splitting responsibilities by abstraction"
date: 2014-01-22 23:02
comments: true
categories: ["functional programming", "dev practices"]
---

Today I was looking at some code, this gist of which was to produce a list of `Widget` from a single `Widget` to fit into a `Qux`. There had been some trouble naming the class that housed this responsibility, and it had ended up as an uncomfortable `PaddedSingleWidgetList`.

```csharp
public interface IPaddedSingleWidgetList {
    IEnumerable<Widget> BuildFrom(Widget widget, int length);
}
```

From the types and names used it would be reasonable to guess this code produces a list of `Widget` of the specified `length`, possibly padding it out with `null` or some default `Widget` value. Reasonable, but wrong:

```csharp
public class PaddedSingleWidgetList : IPaddedSingleWidgetList {
    public IEnumerable<Widget> BuildFrom(Widget widget, int length) {
        var padding = Enumerable.Repeat(Widget.EmptyWidget, length - 1);
        return new[] { StandaloneWidget(widget) }.Concat(padding);
    }

    private Widget StandaloneWidget(Widget w) {
        //return an altered widget
        var standalone = new Widget();
        standalone.Foo = w.Foo;
        return standalone;
    }
}
```

Our guess was incorrect because the types we were using were too specific. `BuildFrom` knows it has a `Widget` and so can inspect its fields and use that to change behaviour, create new `Widget` instances, and use `Widget.EmptyWidget` as a default. 

## Improving our guessing

If instead the type was `IEnumerable<T> SomeMethod<T>(T value, T defaultValue, int length)`, and we ban reflection and exceptions and the like, we could make a much more reliable guess^[We could improve this type to further narrow the possible implementations, but even this small change brings us some advantages.]. In this case `BuildFrom` knows nothing specific about the type `T`, so it can't modify `value` or `defaultValue`, nor can it arbitrarily create instances. Our guess becomes that the output contains `value`, and pads out the rest of the list with `defaultValue` to reach `length`.

Abstracting away the specifics of a type with a type parameter (a.k.a. parametric polymorphism) in this way is very useful. It limits the number of possible implementations (including the number of buggy implementations possible), which makes it easier for us to guess what the code does just from the type.^[In some cases we can restrict the number of reasonable implementations to one, which means if it compiles it is almost guaranteed to work. One of my favourites is this: `Func<A,C> X<A,B,C>(Func<B,C> f, Func<A,B> g)`. If you get `X` compiling and don't deliberately break it by throwing an exception or going in to an infinite loop, then your `X` will be the correct implementation!]

## Abstracting responsibilities

Back to `PaddedSingleWidgetList`, let's separate the code that needs to know the specifics about a `Widget` from the code we can abstract. The `StandaloneWidget()` method needs to know how to transform a `Widget`, but the padding logic could use the `SomeMethod` type signature which will work for any type `T`.




